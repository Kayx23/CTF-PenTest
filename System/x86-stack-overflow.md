# x86 Stack Overflow

The writeup is based on **x86 architecture**. 

Below is a breakdown of how memory is allocated for a program. [image credit](http://riseandhack.blogspot.com/2014/04/understanding-stack-precusor-to.html)

<img src="http://1.bp.blogspot.com/-r3sr9vMjUss/Uz3QWckr-FI/AAAAAAAAAEI/fyZoieLZ4FI/s1600/Stack.jpg">

The **stack** grows downwards and **heap** grows upwards for x86. We focus on overflowing the stack in this writeup. 

===> note that "the top of the stack" refers to the <ins>lower memory address</ins> where stack grows (from function calls). 
 
## Core Idea
Look at **one stack frame**. The idea is that we want to overflow the entire buffer in the frame, and write to the EIP - where <ins>the address of first byte of the next instruction</ins> to be executed is. So when the function is about to return, instead of returning, we want to use EIP to point the CPU to the start of our malicious payload (or the start of the nop sled if padded). **The payload is in ESP**, which is a stack pointer that holds the address of the most-recently pushed value on the stack. How do we do that?

We pass the following to the program function: 
```
filler (to overflow the buffer and EBP but stop before hitting EIP) + 
address of JMP ESP (4 bytes, want this to be in EIP) + 
nop sled (\x090 of some amounts) +
shellcode
```
The key is to use `JMP ESP`, which asks the program to make a jump to the content of ESP - that is, to the start of our payload. Then, the value in ESP gets executed (NOPs + Shellcode). 

### General Steps
1. Spiking - identify **what function** is vulnerable for overflow
2. Fuzzing - use the function found in spiking, find out **the ballpark of the number of characters that would break the program**
3. Finding the Offset to EIP with bytearray, to determine **the length of the filler**. To confirm the offset is correct, pass "filler" + "BBBB" to the function, and we should expect to see `42424242` in EIP (`42` is the hex of `B`) and nothing in ESP. 
4. Finding "Bad Characters". These characters have special meanings to the program, so we **don't want them present in the memory address of our `JMP ESP` pointer our payload**. 
5. Find **the address of `JMP ESP`** from a module that's currently running & compiled without BOF protections (e.g. ASLR, DEP). Exclude the ones with bad characters. 
7. Prepare the payload in hex; specified the x86 architecture, output language, and exclude the use of bad characters. 
8. Exploiting the System with `fillter + jmp_esp_return + nop + payload`
